TODO

- asynchronous call: immediately offload

- currently the succeeding thread of an operation, will execute all pending operations. This could be problematic
because a user thread would like to return 'asap'.

- remote / local invocation

- replicating the write.

- padding on the segment.

- padding on the invocation

- each partition should generate long with the partition id included.

- the invocationfuture relies on locking, which totally sucks.
    - how can a thread that is waiting for an invocation help out?

- dealing with overload in the generated partition

- the lock completion is missing; so a lock can be started, but there is no way to know when the lock has been fully
completed. Only the thread that is scheduling a segment will be able to indicate when the locking is done

- dealing with locking in generated partition

- when lock is acquired on a segment, there is currently no way to know when all threads have completed and
the segment is exclusively owned

- the dispatch method needs to be generated correctly

- deadlock: we need to make sure that if an operation on a segment is executed while already executing from
a different segment, they you are not going to deadlock (because the lock on the original segment is not released)

- optimization with reading immutable data, volatile read would be enough. more thinking needed.

- optimization for operations that don't return a response since there is no

- we need to check during the execution of pending work if the segment is locked.

- concurrent invocations on the same cell, caused new invocationfuture to be created. Would be nice if they could be pooled.

- invocationfuture optimized for primitives instead of creating an object.

- when an asynchronous call is done, instead of doing a notify, just drop the callback + result in some executor and
have it processed. This way there is no blocking going on.

- instead of exposing completable future (which we can do), also expose version where a callback interface is used.
This prevents the need to create a completablefuture instance. Only the callback is needed, which can be recycled.

- dealing with backpressure: currently a segment will reject the claiming of the slot by returning a Segment.CLAIM_SLOT_NO_CAPACITY
but we are throwing an exception. At this point you want to deal with backing off.

- arg mapping and reference

- arg mapping an compacting primitives; each primitive arg now takes up one long field. But e.g. 64 booleans could be pushed into
a single long field.

- actual implementation of the lock

- do we need to expose the cell

- calls to the HazelcastInstance.getFoo methods will always return a new instance.

DONE

- async method is implemented by immediately offloading to a scheduler.
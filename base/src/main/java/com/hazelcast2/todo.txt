TODO

- some kind of backup policy when there is no place in the sector.

- performance: currently the system is mostly yielding

- the completion service should deal with exception. Currently it only knows about a normal value, but
  it could be that it is an exception

- the create cell function should be a remote call if needed.

- cell: there are 2 parts of storing 'cell' based data. One is the actual storage of the cell. The other is the
object that is used during an operation on that cell. It could contain flags like isDirty; something not needed
for the actual stored cell data. Currently the cell would serve these 2 purposes and that is no good because
it has inflated concerns and the object becomes bigger than strictly required because of the processing fiels.

    - change record..

    - a read operation doesn't need to receive a change record, it can receive the id and get the data directly

- dealing with floats

- currently the succeeding thread of an operation, will execute all pending operations. This could be problematic
because a user thread would like to return 'asap'.

- remote / local invocation

- replicating the write.

- padding on the invocation

- dealing with overload in the generated sector

- sector locking

    - the lock completion is missing; so a lock can be started, but there is no way to know when the lock has been fully
    completed. Only the thread that is scheduling a segment will be able to indicate when the locking is done

    - dealing with locking in generated sector

    - we need to check during the execution of pending work if the segment is locked.

- when lock is acquired on a sector, there is currently no way to know when all threads have completed and
the segment is exclusively owned

- deadlock: we need to make sure that if an operation on a segment is executed while already executing from
a different segment, they you are not going to deadlock (because the lock on the original segment is not released)

- optimization with reading immutable data, volatile read would be enough. more thinking needed.

- optimization for operations that don't return a response since there is no

- concurrent invocations on the same cell, caused new invocationfuture to be created. Would be nice if they could be pooled.

- invocationfuture optimized for primitives instead of creating an object.

- when an asynchronous call is done, instead of doing a notify, just drop the callback + result in some executor and
have it processed. This way there is no blocking going on.

- instead of exposing completable future (which we can do), also expose version where a callback interface is used.
This prevents the need to create a completablefuture instance. Only the callback is needed, which can be recycled.

- dealing with backpressure: currently a segment will reject the claiming of the slot by returning a Segment.CLAIM_SLOT_NO_CAPACITY
but we are throwing an exception. At this point you want to deal with backing off.

- arg mapping an compacting primitives; each primitive arg now takes up one long field. But e.g. 64 booleans could be pushed into
a single long field.

- actual implementation of the lock

- calls to the HazelcastInstance.getFoo methods will always return a new instance.

RESEARCH:

    http://en.wikipedia.org/wiki/Open_addressing
    http://www.coverfire.com/articles/queueing-in-the-linux-network-stack/

DONE

- rename invocation to invocationslot.

- completion token for calls with a response.
    - for a completion token, we need to have an id (callid). This call id can be unique within a hz-instance,
    but if a serviceid is attached, it needs to be unique within a service. The advantage of having mulitple
    id-generators is that you have less contention. But how many id generators should you have. And should
    it be a striped id-generator, or should each service have its own id generator.

- dealing with double

- the readonly field on the sectormethodmodel needs to be set

- added the atomicreference

- arg mapping and reference

- padding on the segment.

- asynchronous call: immediately offload

- rename the 'partitions' to sectors. Because the sectors together will form a single sector.

- async method is implemented by immediately offloading to a scheduler.